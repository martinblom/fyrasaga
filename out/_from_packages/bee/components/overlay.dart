// Auto-generated from overlay.html.
// DO NOT EDIT.

library x_overlay;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import 'dart:async';
import 'dart:html';
import 'package:web_ui/web_ui.dart';



/*
 *
 * tests:
 *
 * test esc behavior -> should close on esc of no younger element is active
 * test scrollbar callculation
 * test should hide itself,
 * test if provided closeCallback gets calles
 * test if component still work without provided closeCallback
 * test component still works but shows a warning if closeCallback is not callable
 *
 */

class State {
  static const ACTIVE = const State._(0);
  static const DEACTIVE = const State._(1);

  final int value;
  const State._(this.value);
}

@observable
class OverlayComponent extends WebComponent with Observable  {
  /** Autogenerated from the template. */

  /** CSS class constants. */
  static Map<String, String> _css = {".overlay-backdrop-active":"overlay-backdrop-active",".x-overlay-backdrop":"x-overlay-backdrop",".x-overlay-backdrop-close":"x-overlay-backdrop-close",".x-overlay-body":"x-overlay-body"};

  /** This field is deprecated, use getShadowRoot instead. */
  get _root => getShadowRoot("x-overlay");
  static final __shadowTemplate = new autogenerated.DocumentFragment.html('''
      
      <style>
body {
  overflow: visible;
  overflow-y: scroll;
}
.overlay-backdrop-active body {
  overflow: hidden;
}
.x-overlay-backdrop {
  background-color: rgba(252, 252, 252, 0.7);
  -ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#B3FCFCFC, endColorstr=#B3FCFCFC)";
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 998;
  overflow-x: auto;
  overflow-y: scroll;
  display: none;
}
.x-overlay-backdrop-close {
  color: #aaa;
  font-size: 30px;
  width: 30px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  border: 0;
  position: fixed;
  top: 10px;
  right: 10px;
  cursor: pointer;
}
.x-overlay-body {
  border: 1px solid #ccc;
  z-index: 999;
  -moz-box-shadow: -1px 1px 1px rgba(0, 0, 0, .2);
  -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
  box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
  background: #fff;
  position: static;
  margin: 60px auto;
  padding: 60px;
}
</style><div class="x-overlay-backdrop q-x-overlay-backdrop">
        <div class="x-overlay-backdrop-close q-x-overlay-backdrop-close" title="Press ESC to close">Ã—</div>
        <div class="x-overlay-body q-overlay">
          <content></content>
        </div>
      </div>
    ''');
  autogenerated.DivElement __e51;
  autogenerated.Template __t;

  void created_autogenerated() {
    var __root = createShadowRoot("x-overlay");
    __t = new autogenerated.Template(__root);
    __root.nodes.add(__shadowTemplate.clone(true));
    __e51 = __root.nodes[2].nodes[3];
    __t.oneWayBind(() => elementTimestamp, (e) { if (__e51.dataset['element-timestamp'] != e) __e51.dataset['element-timestamp'] = e; }, false, false);
    __t.create();
  }

  void inserted_autogenerated() {
    __t.insert();
  }

  void removed_autogenerated() {
    __t.remove();
    __t = __e51 = null;
  }

  /** Original code from the component. */


  StreamSubscription __$clickSubscription;
  StreamSubscription get clickSubscription {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'clickSubscription');
    }
    return __$clickSubscription;
  }
  set clickSubscription(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'clickSubscription',
          __$clickSubscription, value);
    }
    __$clickSubscription = value;
  }
  StreamSubscription __$touchSubscription;
  StreamSubscription get touchSubscription {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'touchSubscription');
    }
    return __$touchSubscription;
  }
  set touchSubscription(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'touchSubscription',
          __$touchSubscription, value);
    }
    __$touchSubscription = value;
  }
  StreamSubscription __$keySubscription;
  StreamSubscription get keySubscription {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'keySubscription');
    }
    return __$keySubscription;
  }
  set keySubscription(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'keySubscription',
          __$keySubscription, value);
    }
    __$keySubscription = value;
  }
  String __$elementTimestamp;
  String get elementTimestamp {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'elementTimestamp');
    }
    return __$elementTimestamp;
  }
  set elementTimestamp(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'elementTimestamp',
          __$elementTimestamp, value);
    }
    __$elementTimestamp = value;
  }
  String __$width = "600px";
  String get width {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'width');
    }
    return __$width;
  }
  set width(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'width',
          __$width, value);
    }
    __$width = value;
  }
  DivElement __$_backdrop;
  DivElement get _backdrop {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, '_backdrop');
    }
    return __$_backdrop;
  }
  set _backdrop(DivElement value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, '_backdrop',
          __$_backdrop, value);
    }
    __$_backdrop = value;
  }
  State __$state = State.DEACTIVE;
  State get state {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'state');
    }
    return __$state;
  }
  set state(State value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'state',
          __$state, value);
    }
    __$state = value;
  }

  void created() {
    this._add_scrollbar_info();
  }

  void inserted() {
    this._backdrop = getShadowRoot('x-overlay').query('.q-x-overlay-backdrop');
    this._updateState(this.state);
    getShadowRoot('x-overlay').query('.q-overlay').style.width = this.width;
  }

  void hide() {
    _updateState(State.DEACTIVE);
  }

  void show() {
    _updateState(State.ACTIVE);
  }

  void removed() {
    this._hide();
  }

  void _add_scrollbar_info() {
    // scrollbar width detection
    // http://jdsharp.us/jQuery/minute/calculate-scrollbar-width.php
    Element div = new Element.html('<div style="width:50px;height:50px;overflow:hidden;position:absolute;top:-200px;left:-200px;"><div style="height:100px;"></div>');
    // append the div, do the calculation and then remove it
    query('body').append(div);
    int width1 = div.clientWidth;
    div.style.overflowY = 'scroll';
    int width2 = div.clientWidth;
    div.remove();
    int scrollbarWidth = width1 - width2;
    switch (scrollbarWidth) {
      case 0:
        query('body').classes.add('scrollbar0');
        break;
      case 20:
        query('body').classes.add('scrollbar20');
        break;
      default:
        query('body').classes.add('scrollbar15');
    }
  }

  void _removeClickHandler(event) {
    // close the overlay in case the user clicked outside of the overlay content area
    Element backdrop;
    if (event.target.classes.contains('q-x-overlay-backdrop')) {
      backdrop = event.target;
    } else if (event.target.classes.contains('q-x-overlay-backdrop-close')) {
      backdrop = event.target.parent;
    }
    if (backdrop != null && backdrop.contains(getShadowRoot('x-overlay').query('.q-overlay[data-element-timestamp="${this.elementTimestamp}"]'))) {
      event.preventDefault();
      _updateState(State.DEACTIVE);
    }
  }

  _updateState(var state) {
    this.state = state;
    if (this.state == State.ACTIVE) {
      this._backdrop.style.display = 'block';
      // the attribute elementTimestamp represents the time the popover was activated which is important for 2 reasons
      // * identify the overlay in the dom
      // * find out which layer/element to close on esc
      // this implmentation assumes that multiple elements can't be activated at the exact same millisecond
      this.elementTimestamp = new DateTime.now().millisecondsSinceEpoch.toString();
      query("html").classes.add('overlay-backdrop-active');
      this.clickSubscription = document.onClick.listen(null);
      this.clickSubscription.onData(this._removeClickHandler);
      this.touchSubscription = document.onTouchStart.listen(null);
      this.touchSubscription.onData(this._removeClickHandler);
      this.keySubscription = window.onKeyUp.listen(null);
      this.keySubscription.onData(this._keyHandler);
    } else {
      this._hide();
    }
  }

  void _hide() {
    this._backdrop.style.display = 'none';
    // the element is deactive and we give it 0 as timestamp to make sure
    // you can't find it by getting the max of all elements with the data attribute
    this.elementTimestamp = "0";
    if (this.clickSubscription != null) { try { this.clickSubscription.cancel(); } on StateError {}; }
    if (this.touchSubscription != null) { try { this.touchSubscription.cancel(); } on StateError {}; }
    if (this.keySubscription != null) { try { this.keySubscription.cancel(); } on StateError {}; }
    List<Element> backdrops = queryAll('.q-x-overlay-backdrop');
    // TODO check for visible getter in the future, see https://code.google.com/p/dart/issues/detail?id=6526
    Iterable<Element> visibleBackdrops = backdrops.where((Element backdrop) => backdrop.style.display != 'none');
    if (visibleBackdrops.length == 0) {
      // to reenable scrolling we reset the body's style attribute (but only if we are hiding the last overlay)
      query("html").classes.remove('overlay-backdrop-active');
    }
  }

  void _keyHandler(KeyboardEvent event) {
    // expected app behavior: when ESC is pressed only the latest active element handles ESC
    //
    // this function removes this overlay in case it is the youngest in the dom
    // which is determinded by the data attribute elementTimestamp
    //
    // TODO: potential race condition!
    // if we have two overlays (A & B) and the topmost overlay (A) manages to
    // remove itself from the dom before the second overlay (B) can query for all overlays (A & B)
    // it will remove itself
    if (event.keyCode == 27) {
      List<int> escElements = queryAll('[data-element-timestamp]').map((element) => int.parse(element.dataset['element-timestamp']));
      String youngestEscElement = escElements.fold(0, (prev, element) => (prev > element) ? prev : element).toString();
      if (youngestEscElement == this.elementTimestamp) {
        this._updateState(State.DEACTIVE);
      }
    }
  }
}
//@ sourceMappingURL=overlay.dart.map