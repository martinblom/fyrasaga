// Auto-generated from popover.html.
// DO NOT EDIT.

library x_popover;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import 'dart:async';
import 'dart:html';
import 'package:web_ui/web_ui.dart';
import '../../../../packages/bee/utils/html_helpers.dart';



class State {
  static const ACTIVE = const State._(0);
  static const DEACTIVE = const State._(1);

  final int value;
  const State._(this.value);
}

@observable
class PopoverComponent extends WebComponent with Observable  {
  /** Autogenerated from the template. */

  /** CSS class constants. */
  static Map<String, String> _css = {".x-popover-arrow-up-outline":"x-popover-arrow-up-outline",".x-popover-dialog":"x-popover-dialog",".x-launch-area":"x-launch-area",".x-popover-wrapper":"x-popover-wrapper",".x-popover-body":"x-popover-body",".x-popover-arrow-up-body":"x-popover-arrow-up-body",".x-popover-arrow":"x-popover-arrow"};

  /** This field is deprecated, use getShadowRoot instead. */
  get _root => getShadowRoot("x-popover");
  static final __shadowTemplate = new autogenerated.DocumentFragment.html('''
      
      <style>
.x-popover-wrapper {
  position: relative;
}
.x-popover-dialog {
  position: absolute;
  top: 8px;
  z-index: 999;
  width: 213px;
  border: 1px solid #ccc;
  -moz-box-shadow: -1px 1px 1px rgba(0, 0, 0, .2);
  -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
  box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
  background: #fff;
}
.x-popover-arrow {
  position: absolute;
  top: -16px;
  left: 20px;
}
span.x-popover-arrow-up-outline {
  border-color: transparent transparent #bbb transparent;
  border-style: solid;
  border-width: 8px;
  width: 0;
  height: 0;
  display: block;
}
span.x-popover-arrow-up-body {
  border-color: transparent transparent #fff transparent;
  border-style: solid;
  border-width: 8px;
  width: 0;
  height: 0;
  display: block;
  margin-top: -15px;
}
.x-popover-body {
  padding: 15px;
}
.x-launch-area {
  display: inline;
}
.x-launch-area:hover {
  cursor: pointer;
  color: #aaa;
}
</style><div class="x-launch-area q-launch-area">
        <content select=".launch-area"></content>
      </div>
      <!-- We use disblay block/none to toggle the visibility of the popover since
           content tags inside templates don\'t work at the moment (Web UI 0.4.5)
           see https://github.com/dart-lang/web-ui/issues/228

           In the future we want to use:
           <template instantiate if="state == State.ACTIVE">
              ...
              <content select=".body"></content>
              ...
           </template>
      -->
      <div class="x-popover-wrapper q-x-popover-wrapper">
        <div class="x-popover-dialog">
          <div class="x-popover-header">
            <div class="x-popover-arrow q-x-popover-arrow">
              <span class="x-popover-arrow-up-outline"></span>
              <span class="x-popover-arrow-up-body"></span>
            </div>
          </div>
          <div class="x-popover-body">
            <content select=".body"></content>
          </div>
          <div class="x-popover-footer"></div>
        </div>
      </div>

    ''');
  autogenerated.DivElement __e55;
  autogenerated.Template __t;

  void created_autogenerated() {
    var __root = createShadowRoot("x-popover");
    __t = new autogenerated.Template(__root);
    __root.nodes.add(__shadowTemplate.clone(true));
    __e55 = __root.nodes[6];
    __t.oneWayBind(() => elementTimestamp, (e) { if (__e55.dataset['element-timestamp'] != e) __e55.dataset['element-timestamp'] = e; }, false, false);
    __t.create();
  }

  void inserted_autogenerated() {
    __t.insert();
  }

  void removed_autogenerated() {
    __t.remove();
    __t = __e55 = null;
  }

  /** Original code from the component. */


  StreamSubscription __$documentClick;
  StreamSubscription get documentClick {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'documentClick');
    }
    return __$documentClick;
  }
  set documentClick(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'documentClick',
          __$documentClick, value);
    }
    __$documentClick = value;
  }
  StreamSubscription __$documentTouch;
  StreamSubscription get documentTouch {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'documentTouch');
    }
    return __$documentTouch;
  }
  set documentTouch(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'documentTouch',
          __$documentTouch, value);
    }
    __$documentTouch = value;
  }
  StreamSubscription __$toggleClick;
  StreamSubscription get toggleClick {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'toggleClick');
    }
    return __$toggleClick;
  }
  set toggleClick(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'toggleClick',
          __$toggleClick, value);
    }
    __$toggleClick = value;
  }
  StreamSubscription __$toggleTouch;
  StreamSubscription get toggleTouch {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'toggleTouch');
    }
    return __$toggleTouch;
  }
  set toggleTouch(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'toggleTouch',
          __$toggleTouch, value);
    }
    __$toggleTouch = value;
  }
  StreamSubscription __$keySubscription;
  StreamSubscription get keySubscription {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'keySubscription');
    }
    return __$keySubscription;
  }
  set keySubscription(StreamSubscription value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'keySubscription',
          __$keySubscription, value);
    }
    __$keySubscription = value;
  }
  String __$elementTimestamp;
  String get elementTimestamp {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'elementTimestamp');
    }
    return __$elementTimestamp;
  }
  set elementTimestamp(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'elementTimestamp',
          __$elementTimestamp, value);
    }
    __$elementTimestamp = value;
  }
  String __$width;
  String get width {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'width');
    }
    return __$width;
  }
  set width(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'width',
          __$width, value);
    }
    __$width = value;
  }
  State __$state = State.DEACTIVE;
  State get state {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'state');
    }
    return __$state;
  }
  set state(State value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'state',
          __$state, value);
    }
    __$state = value;
  }
  DivElement __$_popoverWrapper;
  DivElement get _popoverWrapper {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, '_popoverWrapper');
    }
    return __$_popoverWrapper;
  }
  set _popoverWrapper(DivElement value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, '_popoverWrapper',
          __$_popoverWrapper, value);
    }
    __$_popoverWrapper = value;
  }

  // CSS Styles
  String __$left;
  String get left {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'left');
    }
    return __$left;
  }
  set left(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'left',
          __$left, value);
    }
    __$left = value;
  }
  String __$right;
  String get right {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'right');
    }
    return __$right;
  }
  set right(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'right',
          __$right, value);
    }
    __$right = value;
  }
  String __$top;
  String get top {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'top');
    }
    return __$top;
  }
  set top(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'top',
          __$top, value);
    }
    __$top = value;
  }
  String __$bottom;
  String get bottom {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'bottom');
    }
    return __$bottom;
  }
  set bottom(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'bottom',
          __$bottom, value);
    }
    __$bottom = value;
  }
  String __$arrowLeft;
  String get arrowLeft {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'arrowLeft');
    }
    return __$arrowLeft;
  }
  set arrowLeft(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'arrowLeft',
          __$arrowLeft, value);
    }
    __$arrowLeft = value;
  }
  String __$arrowRight;
  String get arrowRight {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'arrowRight');
    }
    return __$arrowRight;
  }
  set arrowRight(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'arrowRight',
          __$arrowRight, value);
    }
    __$arrowRight = value;
  }
  String __$arrowTop;
  String get arrowTop {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'arrowTop');
    }
    return __$arrowTop;
  }
  set arrowTop(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'arrowTop',
          __$arrowTop, value);
    }
    __$arrowTop = value;
  }
  String __$arrowBottom;
  String get arrowBottom {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'arrowBottom');
    }
    return __$arrowBottom;
  }
  set arrowBottom(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'arrowBottom',
          __$arrowBottom, value);
    }
    __$arrowBottom = value;
  }

  void inserted() {
    this._popoverWrapper = getShadowRoot('x-popover').query('.q-x-popover-wrapper');
    this._updateState(this.state);
    this._setCssStyles();
    this.documentClick = document.onClick.listen(null);
    this.documentClick.onData(this._hideClickHandler);
    this.documentTouch = document.onTouchStart.listen(null);
    this.documentTouch.onData(this._hideClickHandler);
    this.toggleClick = getShadowRoot('x-popover').query('.q-launch-area').onClick.listen(null);
    this.toggleClick.onData(this.toggle);
    this.toggleTouch = getShadowRoot('x-popover').query('.q-launch-area').onTouchStart.listen(null);
    this.toggleTouch.onData(this.toggle);
    this.keySubscription = window.onKeyUp.listen(null);
    this.keySubscription.onData(this._keyHandler);
  }

  void removed() {
    if (this.documentClick != null) { try { this.documentClick.cancel(); } on StateError {}; }
    if (this.documentTouch != null) { try { this.documentTouch.cancel(); } on StateError {}; }
    if (this.toggleClick != null) { try { this.toggleClick.cancel(); } on StateError {}; }
    if (this.toggleTouch != null) { try { this.toggleTouch.cancel(); } on StateError {}; }
  }

  void toggle(event) {
    if (event != null) {event.preventDefault(); }
    if (this.state == State.ACTIVE) {
      _updateState(State.DEACTIVE);
    } else {
      _updateState(State.ACTIVE);
    }
  }

  void _setCssStyles() {
    Element arrow = getShadowRoot('x-popover').query('.q-x-popover-arrow');
    if (this.left != null) { this._popoverWrapper.style.left = this.left; }
    if (this.right != null) { this._popoverWrapper.style.right = this.right; }
    if (this.top != null) { this._popoverWrapper.style.top = this.top; }
    if (this.bottom != null) { this._popoverWrapper.style.bottom = this.bottom; }
    if (this.arrowLeft != null) { arrow.style.left = this.arrowLeft; }
    if (this.arrowRight != null) { arrow.style.right = this.arrowRight; }
    if (this.arrowTop != null) { arrow.style.top = this.arrowTop; }
    if (this.arrowBottom != null) { arrow.style.bottom = this.arrowBottom; }
  }

  void _hideClickHandler(event) {
    // close the overlay in case the user clicked outside of the overlay content area
    // only exception is when the user clicked on the toggle area (this case is handled by toggle)
    bool clickOutsidePopover = !insideOrIsNodeWhere(event.target, (element) => element.dataset['element-timestamp'] == this.elementTimestamp);
    bool clickOnToggleArea = insideOrIsNodeWhere(event.target, (element) => element.classes.contains('q-launch-area'));
    if (clickOutsidePopover && !clickOnToggleArea) {
      _updateState(State.DEACTIVE);
    }
  }

  _updateState(var state) {
    this.state = state;
    if (this.state == State.ACTIVE) {
      this._popoverWrapper.style.display = 'block';
      // the attribute elementTimestamp represents the time the popover was activated which is important for 2 reasons
      // * identify the popover in the dom
      // * find out which layer to close on esc
      // this implmentation assumes that multiple elements can't be activated at the exact same millisecond
      this.elementTimestamp = new DateTime.now().millisecondsSinceEpoch.toString();
    } else {
      this._popoverWrapper.style.display = 'none';
      // the element is deactive and we give it 0 as timestamp to make sure
      // you can't find it by getting the max of all elements with the data attribute
      this.elementTimestamp = "0";
    }
  }

  void _keyHandler(KeyboardEvent event) {
    // expected app behavior: when ESC is pressed only the latest active element handles ESC
    //
    // this function removes this popover in case it is the youngest in the dom
    // which is determinded by the data attribute elementTimestamp
    //
    // TODO: potential race condition!
    // if we have two overlays (A & B) and the topmost overlay (A) manages to
    // remove itself from the dom before the second overlay (B) can query for all overlays (A & B)
    // it will remove itself
    if (event.keyCode == 27) {
      List<int> escElements = queryAll('[data-element-timestamp]').map((element) => int.parse(element.dataset['element-timestamp']));
      String youngestEscElement = escElements.fold(0, (prev, element) => (prev > element) ? prev : element).toString();
      if (youngestEscElement == this.elementTimestamp) {
        this._updateState(State.DEACTIVE);
      }
    }
  }
}
//@ sourceMappingURL=popover.dart.map